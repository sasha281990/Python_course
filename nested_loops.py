# В этой задаче вам предстоит построить лесенку из чисел. Программа принимает на вход целое положительное число
# n (n<=15) - количество уровней, ваша задача вывести n уровней, в каждом из которых стоят числа
# от 1 до значения уровня.
a = int(input())
for i in range(1, a + 1):
    for j in range(1, i + 1):
        print(j, end=" ")
    print()

# Напишите программу для построения горизонтальных столбчатых диаграмм с помощью символа звёздочки.
a = list(map(int, input().split()))

n = len(a)
for i in range(n):
    for j in range(1):
        print(int(a[i]) * '*', end=' ')
    print()

# Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, что для любого n > 1 найдется простое число p
# в интервале n < p < 2n. Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном
# (проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым. Рамануджан в 1920 году нашел более простое
# доказательство, а Эрдеш в 1932 – еще более простое.
# Ваша задача состоит в том, чтобы решить несколько более общую задачу – а именно по числу n найти количество простых
# чисел p из интервала n < p < 2n.
# Напомним, что число называется простым, если оно делится только само на себя и на единицу.
n = int(input())
count = 0
for p in range(n + 1, 2 * n):
    if p % 2 == 0 and p != 2 or p == 1:
        continue
    d = 3
    is_plain = True
    while d * d <= p:
        if p % d ==0:
            is_plain = False
            break
        d += 2
    if is_plain:
        count += 1
print(count)

# Вот мы с вами и добрались до легендарной сортировки пузырьком.
# Все просто, вам поступает число n - количество элементов в списке, и затем сам список.
# Ваша задача отсортировать список по возрастанию при помощи пузырьковой сортировки, в случае если элементы соседние
# совпадают менять их ненужно.
# В качестве ответа нужно вывести отсортированный список и какое количество раз пришлось переставлять элементы в
# процессе сортировки
n = int(input())
lst = list(map(int, input().split()))
swaps = 0

for i in range(n):
    for j in range(n - i -1):
        if lst[j] > lst[j + 1]:
            lst[j], lst[j + 1] = lst[j + 1], lst[j]
            swaps += 1

print(*lst)
print(swaps)

# Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает. Но теперь Фурик хочет получить
# # хорошую оценку по математике. Для этого Лариса Ивановна, учительница математики, дала ему новое задание.
# a**2 + b = n
# a + b**2 = m
n, m = map(int, input().split())
pairs = 0

for a in range(0, 1001):
    for b in range(0, 1001):
        if (a*a + b == n) and (a + b*b == m):
            pairs += 1

print(pairs)

# Это еще один вид сортировки, который реализуется при помощи вложенных циклов
# Программа получает на вход число n - количество элементов в списке, и затем в следующей строке сам список.
# Ваша задача отсортировать список по возрастанию при помощи сортировки вставками, в случае если элементы соседние
# совпадают менять их ненужно.
# В качестве ответа нужно вывести отсортированный список.
n = int(input())
lst = list(map(int, input().split()))

for i in range(1, n):
    key = lst[i]
    j = i-1
    while j >=0 and key < lst[j] :
        lst[j+1] = lst[j]
        j -= 1
    lst[j+1] = key

print(*lst)
